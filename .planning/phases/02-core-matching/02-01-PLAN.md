---
phase: 02-core-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/seed-lyrics.ts
  - scripts/setup-supabase.sql
autonomous: false
user_setup:
  - service: supabase
    why: "Vector database for lyrics storage and pgvector similarity search"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
    dashboard_config:
      - task: "Create new Supabase project"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Enable pgvector extension"
        location: "Supabase Dashboard -> Database -> Extensions -> search 'vector' -> Enable"

must_haves:
  truths:
    - "Supabase lyrics table exists with id, lyric_text, and embedding vector(1536) columns"
    - "match_lyrics Postgres function exists and returns lyrics ranked by similarity"
    - "~30 curated Taylor Swift lyrics are seeded with pre-generated embeddings"
  artifacts:
    - path: "scripts/setup-supabase.sql"
      provides: "DDL for lyrics table and match_lyrics function"
      contains: "create table lyrics"
    - path: "scripts/seed-lyrics.ts"
      provides: "Seed script that curates lyrics, generates embeddings, and outputs SQL"
      contains: "text-embedding-3-small"
  key_links:
    - from: "scripts/seed-lyrics.ts"
      to: "OpenAI embeddings API"
      via: "openai.embeddings.create"
      pattern: "embeddings\\.create"
    - from: "scripts/setup-supabase.sql"
      to: "Supabase pgvector"
      via: "vector(1536) column type and <#> operator"
      pattern: "vector\\(1536\\)"
---

<objective>
Create the Supabase database schema and seed lyrics dataset with pre-generated embeddings.

Purpose: The matching engine needs a curated lyrics dataset stored in Supabase with pgvector embeddings. This plan creates the database schema (lyrics table + match_lyrics function) and a seed script that curates ~30 Taylor Swift lyrics, generates their embeddings via OpenAI, and produces SQL for insertion.

Output: SQL schema file, seed script, and a seeded Supabase database ready for the matching engine.
</objective>

<execution_context>
@/Users/august/.claude/get-shit-done/workflows/execute-plan.md
@/Users/august/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-matching/02-CONTEXT.md
@.planning/phases/02-core-matching/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase schema SQL and lyrics seed script</name>
  <files>scripts/setup-supabase.sql, scripts/seed-lyrics.ts</files>
  <action>
Create two files:

**1. `scripts/setup-supabase.sql`** — DDL to run in Supabase SQL Editor:

```sql
-- Enable pgvector (also enable via Dashboard > Database > Extensions)
create extension if not exists vector;

-- Lyrics table
create table lyrics (
  id bigserial primary key,
  lyric_text text not null,
  embedding vector(1536)
);

-- Similarity search function using inner product (fastest for normalized OpenAI embeddings)
create or replace function match_lyrics (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  lyric_text text,
  similarity float
)
language sql
as $$
  select
    id,
    lyric_text,
    1 - (embedding <#> query_embedding) as similarity
  from lyrics
  where 1 - (embedding <#> query_embedding) > match_threshold
  order by embedding <#> query_embedding asc
  limit least(match_count, 200);
$$;
```

No indexes — 30 rows don't need them (sequential scan < 1ms). Per research anti-pattern guidance.

**2. `scripts/seed-lyrics.ts`** — Node script that:
- Contains a curated array of ~30 Taylor Swift lyrics (1-2 lines each, punchy single-thought lyrics)
- Calls OpenAI `text-embedding-3-small` to batch-generate embeddings for all lyrics
- Outputs a `seed-lyrics.sql` file with INSERT statements including embedding vectors
- Uses OPENAI_API_KEY from environment

Lyric curation guidelines (per user decisions):
- ~30 lyrics, every one is a banger
- 1-2 lines max per lyric — punchy, single-thought
- No mood tags or metadata — just the lyric text
- Cover diverse emotional range: empowerment, heartbreak, self-doubt, resilience, love, growth, nostalgia, independence
- Mix of eras/albums for variety

Example lyrics to include (Claude's discretion on full selection):
- "Long story short, I survived" (resilience)
- "It's me, hi, I'm the problem, it's me" (self-awareness)
- "I'm the only one of me, baby, that's the fun of me" (self-love)
- "Band-aids don't fix bullet holes" (heartbreak)
- "We are never ever getting back together" (closure)
- "Shake it off" (letting go)
- "This is me trying" (vulnerability)
- "You need to calm down" (boundaries)
- Plus ~22 more covering the emotional spectrum

The script should:
```typescript
import OpenAI from 'openai';
import fs from 'fs';

// Curated lyrics array
const lyrics = [ /* ~30 lyrics */ ];

async function main() {
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

  // Batch embed all lyrics in single API call
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: lyrics
  });

  // Generate SQL INSERT
  let sql = 'INSERT INTO lyrics (lyric_text, embedding) VALUES\n';
  lyrics.forEach((lyric, i) => {
    const vector = `[${response.data[i].embedding.join(',')}]`;
    const escaped = lyric.replace(/'/g, "''");
    sql += `  ('${escaped}', '${vector}')`;
    sql += i < lyrics.length - 1 ? ',\n' : ';\n';
  });

  fs.writeFileSync('scripts/seed-lyrics.sql', sql);
  console.log(`Generated seed-lyrics.sql with ${lyrics.length} lyrics`);
}

main().catch(console.error);
```

Run with: `OPENAI_API_KEY=sk-... npx tsx scripts/seed-lyrics.ts`

Important: Use `text-embedding-3-small` (not ada-002) per research recommendation — 5x cheaper, better accuracy. Lock this model choice and document it in a comment.
  </action>
  <verify>
- `scripts/setup-supabase.sql` exists and contains `create table lyrics`, `vector(1536)`, and `create or replace function match_lyrics`
- `scripts/seed-lyrics.ts` exists and contains array of ~30 lyrics, calls `text-embedding-3-small`, writes SQL file
- `npx tsx scripts/seed-lyrics.ts` runs successfully with valid OPENAI_API_KEY and produces `scripts/seed-lyrics.sql`
  </verify>
  <done>
SQL schema file defines lyrics table with vector column and match_lyrics similarity function. Seed script contains ~30 curated lyrics and generates embeddings SQL via OpenAI API.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Create Supabase project and seed database</name>
  <files>scripts/setup-supabase.sql, scripts/seed-lyrics.ts</files>
  <action>
What was built: SQL schema file and seed script for Supabase lyrics database.

The user must perform these steps (Claude cannot create Supabase projects):

1. **Create Supabase project:**
   - Go to https://supabase.com/dashboard
   - Click "New Project", name it (e.g., "taylor-wwts")
   - Choose a region close to Vercel deployment (e.g., US East)
   - Set a database password and save it

2. **Enable pgvector extension:**
   - In Supabase Dashboard -> Database -> Extensions
   - Search for "vector" and enable it

3. **Run schema SQL:**
   - Go to SQL Editor in Supabase Dashboard
   - Paste contents of `scripts/setup-supabase.sql` and run

4. **Generate and run seed data:**
   - Run: `OPENAI_API_KEY=sk-... npx tsx scripts/seed-lyrics.ts`
   - This generates `scripts/seed-lyrics.sql`
   - Paste contents of `scripts/seed-lyrics.sql` into Supabase SQL Editor and run
   - Verify: Run `SELECT count(*) FROM lyrics WHERE embedding IS NOT NULL;` — should return ~30

5. **Add environment variables:**
   - Copy SUPABASE_URL from: Project Settings -> API -> Project URL
   - Copy SUPABASE_ANON_KEY from: Project Settings -> API -> anon public key
   - Add to Vercel: `vercel env add SUPABASE_URL` and `vercel env add SUPABASE_ANON_KEY`
   - For local development: add both to `.env.local` (or export in shell)

6. **Verify data:**
   - In SQL Editor, run: `SELECT id, lyric_text, (embedding IS NOT NULL) as has_embedding FROM lyrics LIMIT 5;`
   - All rows should have `has_embedding = true`

Resume signal: Type "done" when Supabase is set up, seeded, and env vars are configured in Vercel.
  </action>
  <verify>Run `SELECT count(*) FROM lyrics WHERE embedding IS NOT NULL;` in Supabase SQL Editor — should return ~30. Verify SUPABASE_URL and SUPABASE_ANON_KEY are set in Vercel via `vercel env ls`.</verify>
  <done>Supabase project exists with pgvector enabled, lyrics table seeded with ~30 embedded lyrics, and SUPABASE_URL/SUPABASE_ANON_KEY configured in both Vercel and local environment.</done>
</task>

</tasks>

<verification>
- SQL schema creates lyrics table with vector(1536) column
- match_lyrics function uses inner product operator (<#>) for normalized embeddings
- Seed script curates ~30 diverse Taylor Swift lyrics
- Embeddings generated with text-embedding-3-small (locked model choice)
- Database is seeded with all lyrics having non-null embeddings
- SUPABASE_URL and SUPABASE_ANON_KEY are set in Vercel environment
</verification>

<success_criteria>
Supabase database is live with ~30 lyrics, each having pre-generated embeddings. The match_lyrics function can perform similarity search. Environment variables are configured for both local development and Vercel production.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-matching/02-01-SUMMARY.md`
</output>
