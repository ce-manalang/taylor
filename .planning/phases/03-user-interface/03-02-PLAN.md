---
phase: 03-user-interface
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/App.tsx
  - src/App.css
autonomous: false

must_haves:
  truths:
    - "User can type a life question into a centered text input and submit via Enter or send icon"
    - "After submission, input animates up and loading dots appear in the center"
    - "User sees a single Taylor Swift lyric revealed with typewriter animation"
    - "User can copy the displayed lyric to clipboard with one tap"
    - "Starter questions appear below input on initial load and fill the input on tap without submitting"
    - "UI is mobile-responsive with 48px+ touch targets and 16px+ font sizes"
    - "After seeing a lyric, user can ask another question"
    - "Page feels soft, warm, calm — warm white background, serif lyric, minimal layout"
  artifacts:
    - path: "src/App.tsx"
      provides: "Full application orchestration — state management, API calls, animation flow"
      contains: "askQuestion"
    - path: "src/App.css"
      provides: "Layout and animation styles for the full-page experience"
      contains: "app-container"
  key_links:
    - from: "src/App.tsx"
      to: "src/lib/api-client.ts"
      via: "askQuestion import and call on form submit"
      pattern: "import.*askQuestion.*api-client"
    - from: "src/App.tsx"
      to: "src/components/QuestionInput.tsx"
      via: "renders QuestionInput with value/onChange/onSubmit props"
      pattern: "<QuestionInput"
    - from: "src/App.tsx"
      to: "src/components/LyricDisplay.tsx"
      via: "renders LyricDisplay when lyric state is set"
      pattern: "<LyricDisplay"
    - from: "src/App.tsx"
      to: "src/components/StarterQuestions.tsx"
      via: "renders StarterQuestions with onSelect that fills input"
      pattern: "<StarterQuestions"
---

<objective>
Wire all components together in App.tsx to create the complete end-to-end user experience: ask a question, see loading, receive a lyric with typewriter animation, copy it, ask another.

Purpose: This is the integration layer that brings all Plan 01 components to life with state management, API calls, layout animations (input moves up after submit), and the full interaction flow.

Output: Updated App.tsx and App.css — the complete working application.
</objective>

<execution_context>
@/Users/august/.claude/get-shit-done/workflows/execute-plan.md
@/Users/august/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-interface/03-RESEARCH.md
@.planning/phases/03-user-interface/03-CONTEXT.md
@.planning/phases/03-user-interface/03-01-SUMMARY.md

@src/lib/api-client.ts
@src/types/api.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire App.tsx with full state management, API integration, and layout animation</name>
  <files>src/App.tsx, src/App.css</files>
  <action>
**App.tsx complete rewrite** — orchestrates the entire single-page experience:

**Imports:**
- React: `useState`, `useCallback`
- `askQuestion` from `./lib/api-client`
- All 5 components from `./components/`
- `./App.css`

**State:**
```typescript
const [question, setQuestion] = useState('');
const [lyric, setLyric] = useState<string | null>(null);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [hasSubmitted, setHasSubmitted] = useState(false);
const [typingComplete, setTypingComplete] = useState(false);
```

Use `useState` approach (not `useActionState`) because we need fine control over the multi-phase animation flow: submit -> input moves up -> loading appears -> lyric types in -> copy button fades in.

**handleSubmit callback:**
```typescript
const handleSubmit = useCallback(async () => {
  const trimmed = question.trim();
  if (!trimmed || isLoading) return;

  setHasSubmitted(true);
  setIsLoading(true);
  setLyric(null);
  setError(null);
  setTypingComplete(false);

  const result = await askQuestion(trimmed);

  setIsLoading(false);
  if (result.error) {
    setError(result.error);
  } else if (result.lyric) {
    setLyric(result.lyric);
  }
}, [question, isLoading]);
```

**handleStarterSelect:**
```typescript
const handleStarterSelect = useCallback((q: string) => {
  setQuestion(q);
  // Focus the input after filling (helps mobile UX)
}, []);
```

**handleReset (ask another):**
```typescript
const handleReset = useCallback(() => {
  setQuestion('');
  setLyric(null);
  setError(null);
  setHasSubmitted(false);
  setTypingComplete(false);
}, []);
```

**JSX structure:**
```tsx
<div className={`app-container ${hasSubmitted ? 'submitted' : ''}`}>
  <div className="app-input-area">
    <QuestionInput
      value={question}
      onChange={setQuestion}
      onSubmit={handleSubmit}
      disabled={isLoading}
      compact={hasSubmitted}
    />
    {!hasSubmitted && (
      <StarterQuestions
        onSelect={handleStarterSelect}
        visible={!hasSubmitted}
      />
    )}
  </div>

  <div className="app-response-area">
    {isLoading && <LoadingDots />}

    {error && (
      <p className="app-error">{error}</p>
    )}

    {lyric && !isLoading && (
      <>
        <LyricDisplay
          lyric={lyric}
          onAnimationComplete={() => setTypingComplete(true)}
        />
        {typingComplete && (
          <div className="app-actions">
            <CopyButton text={lyric} />
          </div>
        )}
      </>
    )}

    {(lyric || error) && !isLoading && typingComplete && (
      <button
        type="button"
        className="app-reset-button"
        onClick={handleReset}
      >
        Ask another
      </button>
    )}
  </div>
</div>
```

Note: The "Ask another" button appears after the typing animation finishes. It smoothly resets to the initial centered state. Styled as a subtle text link, not a prominent button.

Note on error display: if there's an error, show it styled like a soft message (same serif font, same area as lyric would appear), and show "Ask another" immediately (no typing to complete). Add `|| error` condition to show reset button when error is present:
```tsx
{((lyric && typingComplete) || error) && !isLoading && (
  <button ... >Ask another</button>
)}
```

**App.css complete rewrite:**

Layout — the key design: initial state has input vertically centered, submitted state has input at top.

```css
.app-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  min-height: 100vh;
  padding: 24px;
  transition: padding-top var(--transition-slow);
}

/* Initial state: input area centered vertically */
.app-input-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 600px;
  transition: all var(--transition-slow);
  /* Center vertically using margin auto trick */
  margin-top: auto;
  margin-bottom: auto;
}

/* After submission: input moves to top area */
.app-container.submitted .app-input-area {
  margin-top: 10vh;
  margin-bottom: 0;
}

.app-response-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 600px;
  flex: 1;
  padding-top: 48px;
}

.app-error {
  font-family: var(--font-serif);
  font-size: 1.125rem;
  color: var(--color-text-muted);
  text-align: center;
  line-height: 1.7;
  animation: fade-in 0.3s ease;
}

.app-actions {
  display: flex;
  justify-content: center;
  animation: fade-in 0.4s ease;
}

.app-reset-button {
  font-family: var(--font-sans);
  font-size: 14px;
  color: var(--color-text-muted);
  margin-top: 32px;
  padding: 10px 20px;
  border-radius: 20px;
  transition: all var(--transition-fast);
  animation: fade-in 0.4s ease;
  min-height: 44px;
}

.app-reset-button:hover {
  color: var(--color-text);
  background: var(--color-bg-secondary);
}
```

Mobile adjustments:
```css
@media (max-width: 600px) {
  .app-container {
    padding: 16px;
  }

  .app-container.submitted .app-input-area {
    margin-top: 5vh;
  }

  .app-response-area {
    padding-top: 32px;
  }
}
```

Reduced motion:
```css
@media (prefers-reduced-motion: reduce) {
  .app-input-area {
    transition: none;
  }
}
```

Delete the old App.css content entirely (it's the Vite scaffold default with centered logo styles). Replace with the above.
  </action>
  <verify>
Run `npm run build` — zero errors. Run `npm run lint` — no errors. Start dev server (`npm run dev`) and verify:
1. Page loads with centered input and "Ask Taylor..." placeholder
2. 3 starter questions appear below input
3. Tapping a starter fills the input (does NOT submit)
4. Typing a question and pressing Enter submits
5. Input animates up, loading dots appear
6. After ~1 second, lyric appears with typewriter effect
7. After typing completes, copy button and "Ask another" appear
8. Copy button copies to clipboard
9. "Ask another" resets to initial centered state
  </verify>
  <done>
Complete working application: user types question in centered input, submits via Enter or send icon, input animates up, loading dots pulse, lyric reveals with typewriter animation in serif font, copy button appears after animation, "Ask another" resets flow. Starter questions fill input on tap. Mobile responsive. All API calls use existing api-client.ts (mock in dev, real in production).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual and functional verification of complete UI</name>
  <files>src/App.tsx, src/App.css</files>
  <action>
Human verification of complete end-to-end user interface. The full interaction flow: centered input, starter questions, type question, submit, input moves up, loading dots, typewriter lyric reveal, copy button, ask another.

Steps to verify:
1. Start dev server: `npm run dev` and open http://localhost:5173
2. **Initial state:** Verify centered input with "Ask Taylor..." placeholder, 3 starter questions below it, warm white background (#FDFCFA), Inter font on UI elements
3. **Starter questions:** Tap "Am I wasting my time on someone who doesn't care?" — verify it fills the input without submitting
4. **Submit flow:** Press Enter to submit. Verify: input shrinks/moves up smoothly, starter questions disappear, three pulsing dots appear in center
5. **Lyric reveal:** After dots disappear, verify: lyric appears character by character (typewriter effect) in Lora serif font, blinking cursor during typing fades after completion, text is medium/elegant size centered
6. **Post-lyric:** After typing completes, verify: small "Copy" button appears below lyric with clipboard icon, "Ask another" text button below that
7. **Copy:** Click "Copy" — verify text copies to clipboard and button changes to "Copied" with checkmark
8. **Reset:** Click "Ask another" — verify it returns to initial centered state
9. **Mobile:** Open DevTools responsive mode (375px width), repeat flow, verify touch targets are 44px+, text readable (16px+), starter questions stack vertically, no horizontal overflow
10. **Aesthetic check:** Does the overall feel match "trusted friend after midnight"? Soft, warm, calm, minimal — like opening a blank journal?
  </action>
  <verify>User types "approved" to confirm all checks pass, or describes issues to fix.</verify>
  <done>Human has confirmed the complete UI experience meets aesthetic and functional requirements.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `npm run lint` passes with zero errors
3. Full interaction flow works in dev: question → loading → lyric → copy → reset
4. Mobile responsive at 375px width — no overflow, readable text, adequate touch targets
5. Aesthetic matches "trusted friend after midnight" tone — soft whites, serif lyrics, minimal layout
6. API client correctly uses mock in dev (immediate feedback) and would use real API in production
</verification>

<success_criteria>
Complete working application where user can type a question, see loading state, receive a lyric with typewriter reveal animation, copy it to clipboard, and ask another question. UI is mobile-responsive with soft/warm/calm aesthetic. Human-verified and approved.
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-interface/03-02-SUMMARY.md`
</output>
